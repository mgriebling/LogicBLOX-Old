//
//  Gates.swift
//  LogicBLOX
//
//  Created by Mike Griebling on 2 Oct 2017.
//  Copyright Â© 2017 Computer Inspirations. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class Gates : NSObject {

    //// Cache

    private struct Cache {
        static let baseColor: UIColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        static let highlightColour: UIColor = UIColor(red: 0.000, green: 0.480, blue: 0.998, alpha: 1.000)
        static let color: UIColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        static let buttonHi: UIColor = UIColor(red: 0.290, green: 0.602, blue: 0.973, alpha: 1.000)
        static let buttonLo: UIColor = UIColor(red: 0.871, green: 0.866, blue: 0.919, alpha: 1.000)
        static let color2: UIColor = UIColor(red: 0.572, green: 0.572, blue: 0.572, alpha: 1.000)
        static let gradientHigh: CGGradient = CGGradient(colorsSpace: nil, colors: [UIColor.white.cgColor, UIColor.white.blended(withFraction: 0.5, of: Gates.buttonHi).cgColor, Gates.buttonHi.cgColor] as CFArray, locations: [0, 0.23, 1])!
        static let gradientLow: CGGradient = CGGradient(colorsSpace: nil, colors: [UIColor.lightGray.cgColor, UIColor.lightGray.blended(withFraction: 0.5, of: UIColor.darkGray).cgColor, UIColor.darkGray.cgColor] as CFArray, locations: [0, 0.2, 0.61])!
        static let gradient: CGGradient = CGGradient(colorsSpace: nil, colors: [Gates.color2.cgColor, UIColor.white.cgColor] as CFArray, locations: [0, 1])!
        static let gradient2: CGGradient = CGGradient(colorsSpace: nil, colors: [UIColor.red.cgColor, UIColor.red.blended(withFraction: 0.5, of: UIColor.white).cgColor, UIColor.white.cgColor] as CFArray, locations: [0.01, 0.39, 1])!
        static let shadow: NSShadow = NSShadow(color: UIColor.black.withAlphaComponent(0.6), offset: CGSize(width: 3, height: 3), blurRadius: 7)
    }

    //// Colors

    @objc dynamic public class var baseColor: UIColor { return Cache.baseColor }
    @objc dynamic public class var highlightColour: UIColor { return Cache.highlightColour }
    @objc dynamic public class var color: UIColor { return Cache.color }
    @objc dynamic public class var buttonHi: UIColor { return Cache.buttonHi }
    @objc dynamic public class var buttonLo: UIColor { return Cache.buttonLo }
    @objc dynamic public class var color2: UIColor { return Cache.color2 }

    //// Gradients

    @objc dynamic public class var gradientHigh: CGGradient { return Cache.gradientHigh }
    @objc dynamic public class var gradientLow: CGGradient { return Cache.gradientLow }
    @objc dynamic public class var gradient: CGGradient { return Cache.gradient }
    @objc dynamic public class var gradient2: CGGradient { return Cache.gradient2 }

    //// Shadows

    @objc dynamic public class var shadow: NSShadow { return Cache.shadow }

    //// Drawing Methods

    @objc dynamic public class func drawAnd(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 77, height: 60), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 77, height: 60), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 77, y: resizedFrame.height / 60)



        //// Variable Declarations
        let colour = highlight ? Gates.highlightColour : Gates.baseColor

        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 43.57, y: 2.03))
        bezierPath.addCurve(to: CGPoint(x: 66.24, y: 10.23), controlPoint1: CGPoint(x: 51.72, y: 1.68), controlPoint2: CGPoint(x: 60.01, y: 4.4))
        bezierPath.addCurve(to: CGPoint(x: 66.24, y: 49.83), controlPoint1: CGPoint(x: 77.92, y: 21.16), controlPoint2: CGPoint(x: 77.92, y: 38.89))
        bezierPath.addCurve(to: CGPoint(x: 43.57, y: 57.99), controlPoint1: CGPoint(x: 60.01, y: 55.66), controlPoint2: CGPoint(x: 51.72, y: 58.38))
        bezierPath.addLine(to: CGPoint(x: 2, y: 58.03))
        bezierPath.addLine(to: CGPoint(x: 2, y: 2.03))
        bezierPath.addLine(to: CGPoint(x: 43.57, y: 2.03))
        bezierPath.addLine(to: CGPoint(x: 43.57, y: 2.03))
        bezierPath.close()
        colour.setStroke()
        bezierPath.lineWidth = 2.5
        bezierPath.stroke()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawOr(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 82, height: 60), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 82, height: 60), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 82, y: resizedFrame.height / 60)



        //// Variable Declarations
        let colour = highlight ? Gates.highlightColour : Gates.baseColor

        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 33.85, y: 2))
        bezierPath.addCurve(to: CGPoint(x: 34.42, y: 2), controlPoint1: CGPoint(x: 33.85, y: 2), controlPoint2: CGPoint(x: 34.42, y: 2))
        bezierPath.addCurve(to: CGPoint(x: 44.63, y: 3.85), controlPoint1: CGPoint(x: 37.88, y: 2.42), controlPoint2: CGPoint(x: 41.3, y: 3.02))
        bezierPath.addCurve(to: CGPoint(x: 66.59, y: 13.87), controlPoint1: CGPoint(x: 52.65, y: 5.85), controlPoint2: CGPoint(x: 60.19, y: 9.19))
        bezierPath.addCurve(to: CGPoint(x: 80.3, y: 29.99), controlPoint1: CGPoint(x: 73.01, y: 18.57), controlPoint2: CGPoint(x: 77.58, y: 24.1))
        bezierPath.addCurve(to: CGPoint(x: 66.59, y: 46.11), controlPoint1: CGPoint(x: 77.58, y: 35.88), controlPoint2: CGPoint(x: 73.01, y: 41.42))
        bezierPath.addCurve(to: CGPoint(x: 34.42, y: 57.92), controlPoint1: CGPoint(x: 57.54, y: 52.74), controlPoint2: CGPoint(x: 46.19, y: 56.68))
        bezierPath.addLine(to: CGPoint(x: 33.85, y: 57.98))
        bezierPath.addLine(to: CGPoint(x: 33.68, y: 58))
        bezierPath.addCurve(to: CGPoint(x: 3.62, y: 57.99), controlPoint1: CGPoint(x: 33.68, y: 58), controlPoint2: CGPoint(x: 12.25, y: 57.99))
        bezierPath.addCurve(to: CGPoint(x: 6.19, y: 54.12), controlPoint1: CGPoint(x: 4.53, y: 56.86), controlPoint2: CGPoint(x: 5.39, y: 55.57))
        bezierPath.addCurve(to: CGPoint(x: 6.19, y: 6.61), controlPoint1: CGPoint(x: 13.48, y: 41), controlPoint2: CGPoint(x: 13.48, y: 19.73))
        bezierPath.addCurve(to: CGPoint(x: 3, y: 2), controlPoint1: CGPoint(x: 5.2, y: 4.83), controlPoint2: CGPoint(x: 4.13, y: 3.3))
        bezierPath.addLine(to: CGPoint(x: 33.68, y: 2))
        bezierPath.addLine(to: CGPoint(x: 33.85, y: 2))
        bezierPath.addLine(to: CGPoint(x: 33.85, y: 2))
        bezierPath.close()
        colour.setStroke()
        bezierPath.lineWidth = 2.5
        bezierPath.stroke()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawShield(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 13, height: 60), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 13, height: 60), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 13, y: resizedFrame.height / 60)



        //// Variable Declarations
        let colour = highlight ? Gates.highlightColour : Gates.baseColor

        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 2, y: 2))
        bezier2Path.addCurve(to: CGPoint(x: 4.3, y: 2), controlPoint1: CGPoint(x: 2, y: 2), controlPoint2: CGPoint(x: 2.86, y: 2))
        bezier2Path.addCurve(to: CGPoint(x: 4.31, y: 58), controlPoint1: CGPoint(x: 14.03, y: 18.41), controlPoint2: CGPoint(x: 14.03, y: 41.59))
        bezier2Path.addCurve(to: CGPoint(x: 2.62, y: 58), controlPoint1: CGPoint(x: 3.7, y: 58), controlPoint2: CGPoint(x: 3.14, y: 58))
        bezier2Path.addCurve(to: CGPoint(x: 5.19, y: 54.13), controlPoint1: CGPoint(x: 3.53, y: 56.87), controlPoint2: CGPoint(x: 4.39, y: 55.58))
        bezier2Path.addCurve(to: CGPoint(x: 5.19, y: 6.61), controlPoint1: CGPoint(x: 12.48, y: 41.01), controlPoint2: CGPoint(x: 12.48, y: 19.74))
        bezier2Path.addCurve(to: CGPoint(x: 2, y: 2), controlPoint1: CGPoint(x: 4.2, y: 4.84), controlPoint2: CGPoint(x: 3.13, y: 3.3))
        bezier2Path.addLine(to: CGPoint(x: 2, y: 2))
        bezier2Path.close()
        colour.setFill()
        bezier2Path.fill()
        colour.setStroke()
        bezier2Path.lineWidth = 1.5
        bezier2Path.stroke()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawNot(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 16, height: 16), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 16, height: 16), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 16, y: resizedFrame.height / 16)



        //// Variable Declarations
        let colour = highlight ? Gates.highlightColour : Gates.baseColor

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 2, y: 2, width: 12, height: 12))
        colour.setStroke()
        ovalPath.lineWidth = 2.5
        ovalPath.stroke()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawBuffer(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 45, height: 52), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 45, height: 52), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 45, y: resizedFrame.height / 52)



        //// Variable Declarations
        let colour = highlight ? Gates.highlightColour : Gates.baseColor

        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 2, y: 2))
        bezierPath.addLine(to: CGPoint(x: 2, y: 50))
        bezierPath.addLine(to: CGPoint(x: 43, y: 26))
        bezierPath.addLine(to: CGPoint(x: 2, y: 2))
        bezierPath.close()
        colour.setStroke()
        bezierPath.lineWidth = 2.5
        bezierPath.stroke()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawOrNorGateR(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 124, height: 60), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false, inputs: CGFloat = 4, joinedPin: CGFloat = 0, joinedOutputPin: CGFloat = 0, inputPinVisible: CGFloat = 1, outputPinVisible: CGFloat = 1, invertInput: CGFloat = 0, invert: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 124, height: 60), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 124, y: resizedFrame.height / 60)



        //// Variable Declarations
        let outputPin1Joined = fmod(joinedOutputPin, 2) == 1
        let outputPin1Visible = outputPinVisible == 1

        //// Group
        //// Symbol Drawing
        let symbolRect = CGRect(x: 19, y: 0, width: 82, height: 60)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

        Gates.drawOr(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch, highlight: highlight)
        context.restoreGState()


        //// Symbol 2 Drawing
        let symbol2Rect = CGRect(x: 99, y: 22, width: 24, height: 16)
        context.saveGState()
        context.clip(to: symbol2Rect)
        context.translateBy(x: symbol2Rect.minX, y: symbol2Rect.minY)
        context.translateBy(x: 20, y: 8)

        Gates.drawOutputPin(frame: CGRect(origin: .zero, size: symbol2Rect.size), resizing: .stretch, highlight: highlight, pinVisible: outputPin1Visible, invert: invert, isJoined: outputPin1Joined)
        context.restoreGState()


        //// Symbol 3 Drawing
        let symbol3Rect = CGRect(x: 0, y: 0, width: 39, height: 60)
        context.saveGState()
        context.clip(to: symbol3Rect)
        context.translateBy(x: symbol3Rect.minX, y: symbol3Rect.minY)

        Gates.drawOrPins(frame: CGRect(origin: .zero, size: symbol3Rect.size), resizing: .stretch, highlight: highlight, inputs: inputs, joinedPin: joinedPin, inputPinVisible: inputPinVisible, invertInput: invertInput)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawXorXnorGateR(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 132, height: 60), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false, inputs: CGFloat = 4, joinedPin: CGFloat = 0, joinedOutputPin: CGFloat = 0, inputPinVisible: CGFloat = 1, outputPinVisible: CGFloat = 1, invertInput: CGFloat = 0, invert: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 132, height: 60), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 132, y: resizedFrame.height / 60)



        //// Variable Declarations
        let outputPin1Joined = fmod(joinedOutputPin, 2) == 1
        let outputPin1Visible = outputPinVisible == 1

        //// Group
        //// Symbol Drawing
        let symbolRect = CGRect(x: 28, y: 0, width: 82, height: 60)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

        Gates.drawOr(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch, highlight: highlight)
        context.restoreGState()


        //// Symbol 2 Drawing
        let symbol2Rect = CGRect(x: 107, y: 22, width: 24, height: 16)
        context.saveGState()
        context.clip(to: symbol2Rect)
        context.translateBy(x: symbol2Rect.minX, y: symbol2Rect.minY)
        context.translateBy(x: 20, y: 8)

        Gates.drawOutputPin(frame: CGRect(origin: .zero, size: symbol2Rect.size), resizing: .stretch, highlight: highlight, pinVisible: outputPin1Visible, invert: invert, isJoined: outputPin1Joined)
        context.restoreGState()


        //// Symbol 3 Drawing
        let symbol3Rect = CGRect(x: 1, y: 0, width: 39, height: 60)
        context.saveGState()
        context.clip(to: symbol3Rect)
        context.translateBy(x: symbol3Rect.minX, y: symbol3Rect.minY)

        Gates.drawOrPins(frame: CGRect(origin: .zero, size: symbol3Rect.size), resizing: .stretch, highlight: highlight, inputs: inputs, joinedPin: joinedPin, inputPinVisible: inputPinVisible, invertInput: invertInput)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawBufferInverterGateR(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 90, height: 52), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false, joinedPin: CGFloat = 0, joinedOutputPin: CGFloat = 0, inputPinVisible: CGFloat = 1, outputPinVisible: CGFloat = 1, invert: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 90, height: 52), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 90, y: resizedFrame.height / 52)



        //// Variable Declarations
        let pin1Joined = fmod(joinedPin, 2) == 1
        let outputPin1Joined = fmod(joinedOutputPin, 2) == 1
        let pin1Visible = inputPinVisible == 1
        let outputPin1Visible = outputPinVisible == 1

        //// Group
        //// Symbol Drawing
        let symbolRect = CGRect(x: 22, y: 0, width: 45, height: 52)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

        Gates.drawBuffer(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch, highlight: highlight)
        context.restoreGState()


        //// Symbol 2 Drawing
        let symbol2Rect = CGRect(x: 65, y: 18, width: 24, height: 16)
        context.saveGState()
        context.clip(to: symbol2Rect)
        context.translateBy(x: symbol2Rect.minX, y: symbol2Rect.minY)
        context.translateBy(x: 20, y: 8)

        Gates.drawOutputPin(frame: CGRect(origin: .zero, size: symbol2Rect.size), resizing: .stretch, highlight: highlight, pinVisible: outputPin1Visible, invert: invert, isJoined: outputPin1Joined)
        context.restoreGState()


        //// Symbol 3 Drawing
        let symbol3Rect = CGRect(x: 0, y: 20, width: 24, height: 12)
        context.saveGState()
        context.clip(to: symbol3Rect)
        context.translateBy(x: symbol3Rect.minX, y: symbol3Rect.minY)

        Gates.drawInputPin(frame: CGRect(x: 0, y: 0, width: symbol3Rect.width, height: symbol3Rect.height), highlight: highlight, pinVisible: pin1Visible, invert: false, isJoined: pin1Joined)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawAndNandGateR(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 120, height: 60), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false, inputs: CGFloat = 4, joinedPin: CGFloat = 0, joinedOutputPin: CGFloat = 0, inputPinVisible: CGFloat = 1, outputPinVisible: CGFloat = 1, invertInput: CGFloat = 0, invert: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 120, height: 60), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 120, y: resizedFrame.height / 60)



        //// Variable Declarations
        let outputPin1Joined = fmod(joinedOutputPin, 2) == 1
        let outputPin1Visible = outputPinVisible == 1

        //// Group
        //// Symbol Drawing
        let symbolRect = CGRect(x: 22, y: 0, width: 77, height: 60)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

        Gates.drawAnd(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch, highlight: highlight)
        context.restoreGState()


        //// Symbol 2 Drawing
        let symbol2Rect = CGRect(x: 0, y: 2, width: 25, height: 56)
        context.saveGState()
        context.clip(to: symbol2Rect)
        context.translateBy(x: symbol2Rect.minX, y: symbol2Rect.minY)

        Gates.drawAndPins(frame: CGRect(origin: .zero, size: symbol2Rect.size), resizing: .stretch, highlight: highlight, inputs: inputs, joinedPin: joinedPin, inputPinVisible: inputPinVisible, invertInput: invertInput)
        context.restoreGState()


        //// Symbol 3 Drawing
        let symbol3Rect = CGRect(x: 96, y: 22, width: 24, height: 16)
        context.saveGState()
        context.clip(to: symbol3Rect)
        context.translateBy(x: symbol3Rect.minX, y: symbol3Rect.minY)
        context.translateBy(x: 20, y: 8)

        Gates.drawOutputPin(frame: CGRect(origin: .zero, size: symbol3Rect.size), resizing: .stretch, highlight: highlight, pinVisible: outputPin1Visible, invert: invert, isJoined: outputPin1Joined)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawBlockGate(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 127, height: 121), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false, inputs: CGFloat = 4, outputs: CGFloat = 1, joinedPin: CGFloat = 0, joinedOutputPin: CGFloat = 0, inputPinVisible: CGFloat = 1, outputPinVisible: CGFloat = 1, invertInput: CGFloat = 0, invertOutput: CGFloat = 0, name: String = "I/O 1") {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 127, height: 121), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 127, y: resizedFrame.height / 121)



        //// Variable Declarations
        let colour = highlight ? Gates.highlightColour : Gates.baseColor
        let inputsExt: CGFloat = max(0, inputs - 4)
        let joinedPinExt: CGFloat = floor(joinedPin / 16.0)
        let inputPinVisibleExt: CGFloat = max(0, inputPinVisible - 4)
        let invertInputExt: CGFloat = floor(invertInput / 16.0)

        //// Group
        //// Rectangle Drawing
        let rectangleRect = CGRect(x: 27, y: 6, width: 72, height: 109)
        let rectanglePath = UIBezierPath(rect: rectangleRect)
        colour.setStroke()
        rectanglePath.lineWidth = 2.5
        rectanglePath.stroke()
        let rectangleStyle = NSMutableParagraphStyle()
        rectangleStyle.alignment = .center
        let rectangleFontAttributes = [
            .font: UIFont(name: "HelveticaNeue-Bold", size: UIFont.systemFontSize)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: rectangleStyle,
        ] as [NSAttributedStringKey: Any]

        let rectangleTextHeight: CGFloat = name.boundingRect(with: CGSize(width: rectangleRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: rectangleFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: rectangleRect)
        name.draw(in: CGRect(x: rectangleRect.minX, y: rectangleRect.minY + (rectangleRect.height - rectangleTextHeight) / 2, width: rectangleRect.width, height: rectangleTextHeight), withAttributes: rectangleFontAttributes)
        context.restoreGState()


        //// InputPins1 Drawing
        let inputPins1Rect = CGRect(x: 3, y: 5, width: 25, height: 56)
        context.saveGState()
        context.clip(to: inputPins1Rect)
        context.translateBy(x: inputPins1Rect.minX, y: inputPins1Rect.minY)

        Gates.drawAndPins(frame: CGRect(origin: .zero, size: inputPins1Rect.size), resizing: .stretch, highlight: highlight, inputs: inputs, joinedPin: joinedPin, inputPinVisible: inputPinVisible, invertInput: invertInput)
        context.restoreGState()


        //// InputPins2 Drawing
        let inputPins2Rect = CGRect(x: 3, y: 60, width: 25, height: 56)
        context.saveGState()
        context.clip(to: inputPins2Rect)
        context.translateBy(x: inputPins2Rect.minX, y: inputPins2Rect.minY)

        Gates.drawAndPins(frame: CGRect(origin: .zero, size: inputPins2Rect.size), resizing: .stretch, highlight: highlight, inputs: inputsExt, joinedPin: joinedPinExt, inputPinVisible: inputPinVisibleExt, invertInput: invertInputExt)
        context.restoreGState()


        //// OutputPins Drawing
        context.saveGState()
        context.translateBy(x: 123, y: 33)
        context.scaleBy(x: -1, y: 1)

        let outputPinsRect = CGRect(x: 0, y: 0, width: 25, height: 56)
        context.saveGState()
        context.clip(to: outputPinsRect)
        context.translateBy(x: outputPinsRect.minX, y: outputPinsRect.minY)

        Gates.drawAndPins(frame: CGRect(origin: .zero, size: outputPinsRect.size), resizing: .stretch, highlight: highlight, inputs: outputs, joinedPin: joinedOutputPin, inputPinVisible: outputPinVisible, invertInput: invertOutput)
        context.restoreGState()

        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawButtonR(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 52, height: 32), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false, state: CGFloat = 0, joinedOutputPin: CGFloat = 0, outputPinVisible: CGFloat = 1) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 52, height: 32), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 52, y: resizedFrame.height / 32)
        let resizedShadowScale: CGFloat = min(resizedFrame.width / 52, resizedFrame.height / 32)



        //// Variable Declarations
        let colour = highlight ? Gates.highlightColour : Gates.baseColor
        let stateText = state == 1 ? "1" : "0"
        let outputPin1Joined = fmod(joinedOutputPin, 2) == 1
        let outputPin1Visible = outputPinVisible == 1

        //// Group
        //// Rectangle Drawing
        let rectangleRect = CGRect(x: 2.5, y: 3.5, width: 25, height: 21)
        let rectanglePath = UIBezierPath(roundedRect: rectangleRect, cornerRadius: 6)
        context.saveGState()
        context.setShadow(offset: CGSize(width: Gates.shadow.shadowOffset.width * resizedShadowScale, height: Gates.shadow.shadowOffset.height * resizedShadowScale), blur: Gates.shadow.shadowBlurRadius * resizedShadowScale, color: (Gates.shadow.shadowColor as! UIColor).cgColor)
        Gates.buttonLo.setFill()
        rectanglePath.fill()
        context.restoreGState()

        colour.setStroke()
        rectanglePath.lineWidth = 2.5
        rectanglePath.stroke()
        let rectangleStyle = NSMutableParagraphStyle()
        rectangleStyle.alignment = .center
        let rectangleFontAttributes = [
            .font: UIFont(name: "HelveticaNeue-Bold", size: 19)!,
            .foregroundColor: UIColor.black,
            .paragraphStyle: rectangleStyle,
        ] as [NSAttributedStringKey: Any]

        let rectangleTextHeight: CGFloat = stateText.boundingRect(with: CGSize(width: rectangleRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: rectangleFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: rectangleRect)
        stateText.draw(in: CGRect(x: rectangleRect.minX, y: rectangleRect.minY + (rectangleRect.height - rectangleTextHeight) / 2, width: rectangleRect.width, height: rectangleTextHeight), withAttributes: rectangleFontAttributes)
        context.restoreGState()


        //// Symbol Drawing
        let symbolRect = CGRect(x: 27, y: 6, width: 24, height: 16)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)
        context.translateBy(x: 20, y: 8)

        Gates.drawOutputPin(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch, highlight: highlight, pinVisible: outputPin1Visible, invert: false, isJoined: outputPin1Joined)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawIndicatorR(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 57, height: 35), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false, state: CGFloat = 0, joinedPin: CGFloat = 0, inputPinVisible: CGFloat = 1) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 57, height: 35), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 57, y: resizedFrame.height / 35)
        let resizedShadowScale: CGFloat = min(resizedFrame.width / 57, resizedFrame.height / 35)



        //// Variable Declarations
        let colour = highlight ? Gates.highlightColour : Gates.baseColor
        let stateText = state == 1 ? "1" : "0"
        let gradientFill = stateText == "1" ? Gates.gradientHigh : Gates.gradientLow
        let pin1Joined = fmod(joinedPin, 2) == 1
        let pin1Visible = inputPinVisible == 1

        //// Group
        //// Symbol Drawing
        let symbolRect = CGRect(x: 2, y: 10, width: 24, height: 12)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

        Gates.drawInputPin(frame: CGRect(x: 0, y: 0, width: symbolRect.width, height: symbolRect.height), highlight: highlight, pinVisible: pin1Visible, invert: false, isJoined: pin1Joined)
        context.restoreGState()


        //// Oval 2 Drawing
        let oval2Path = UIBezierPath(ovalIn: CGRect(x: 27, y: 4, width: 24, height: 24))
        context.saveGState()
        context.setShadow(offset: CGSize(width: Gates.shadow.shadowOffset.width * resizedShadowScale, height: Gates.shadow.shadowOffset.height * resizedShadowScale), blur: Gates.shadow.shadowBlurRadius * resizedShadowScale, color: (Gates.shadow.shadowColor as! UIColor).cgColor)
        UIColor.white.setFill()
        oval2Path.fill()
        context.restoreGState()

        colour.setStroke()
        oval2Path.lineWidth = 2.5
        oval2Path.stroke()


        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 27, y: 4, width: 24, height: 24))
        context.saveGState()
        ovalPath.addClip()
        context.drawRadialGradient(gradientFill,
            startCenter: CGPoint(x: 36.7, y: 12.07), startRadius: 2.71,
            endCenter: CGPoint(x: 34.93, y: 20.07), endRadius: 17.23,
            options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()
        colour.setStroke()
        ovalPath.lineWidth = 2.5
        ovalPath.stroke()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawPin(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 8, height: 8), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false, pinVisible: Bool = true, isJoined: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 8, height: 8), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 8, y: resizedFrame.height / 8)



        //// Variable Declarations
        let colour = highlight ? Gates.highlightColour : Gates.baseColor

        if (isJoined) {
            //// Rectangle 2 Drawing
            let rectangle2Path = UIBezierPath(roundedRect: CGRect(x: 0.5, y: 0.5, width: 7, height: 7), cornerRadius: 3)
            colour.setFill()
            rectangle2Path.fill()
            colour.setStroke()
            rectangle2Path.lineWidth = 1
            rectangle2Path.stroke()
        }


        if (pinVisible) {
            //// Rectangle Drawing
            let rectanglePath = UIBezierPath(roundedRect: CGRect(x: 0.5, y: 0.5, width: 7, height: 7), cornerRadius: 3)
            context.saveGState()
            rectanglePath.addClip()
            context.drawRadialGradient(Gates.gradientHigh,
                startCenter: CGPoint(x: 4, y: 4), startRadius: 0.6,
                endCenter: CGPoint(x: 4, y: 4), endRadius: 3.92,
                options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
            context.restoreGState()
            Gates.highlightColour.setStroke()
            rectanglePath.lineWidth = 1
            rectanglePath.stroke()
        }
        
        context.restoreGState()

    }

    @objc dynamic public class func drawOrPins(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 39, height: 60), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false, inputs: CGFloat = 4, joinedPin: CGFloat = 0, inputPinVisible: CGFloat = 1, invertInput: CGFloat = 0) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 39, height: 60), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 39, y: resizedFrame.height / 60)



        //// Variable Declarations
        let hasInputs2 = inputs == 2
        let hasInputs3 = inputs == 3
        let hasInputs4 = inputs >= 4
        let pin1Joined = fmod(joinedPin, 2) == 1
        let pin2Joined = fmod(floor(joinedPin / 2.0), 2) == 1
        let pin3Joined = fmod(floor(joinedPin / 4.0), 2) == 1
        let pin4Joined = fmod(floor(joinedPin / 8.0), 2) == 1
        let pin1Visible = inputPinVisible == 1
        let pin2Visible = inputPinVisible == 2
        let pin3Visible = inputPinVisible == 3
        let pin4Visible = inputPinVisible == 4
        let pin1Inverted = fmod(invertInput, 2) == 1
        let pin2Inverted = fmod(floor(invertInput / 2.0), 2) == 1
        let pin3Inverted = fmod(floor(invertInput / 4.0), 2) == 1
        let pin4Inverted = fmod(floor(invertInput / 8.0), 2) == 1

        //// Group
        if (hasInputs2) {
            //// In2
            //// 2Pin2
            //// Symbol 2 Drawing
            let symbol2Rect = CGRect(x: 0, y: 36, width: 29, height: 12)
            context.saveGState()
            context.clip(to: symbol2Rect)
            context.translateBy(x: symbol2Rect.minX, y: symbol2Rect.minY)

            Gates.drawInputPin(frame: CGRect(x: 0, y: 0, width: symbol2Rect.width, height: symbol2Rect.height), highlight: highlight, pinVisible: pin2Visible, invert: pin2Inverted, isJoined: pin2Joined)
            context.restoreGState()




            //// 2Pin1
            //// Symbol Drawing
            let symbolRect = CGRect(x: 0, y: 12, width: 29, height: 12)
            context.saveGState()
            context.clip(to: symbolRect)
            context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

            Gates.drawInputPin(frame: CGRect(x: 0, y: 0, width: symbolRect.width, height: symbolRect.height), highlight: highlight, pinVisible: pin1Visible, invert: pin1Inverted, isJoined: pin1Joined)
            context.restoreGState()




        }


        if (hasInputs3) {
            //// In3
            //// 3Pin3
            //// Symbol 4 Drawing
            let symbol4Rect = CGRect(x: 0, y: 44, width: 27, height: 12)
            context.saveGState()
            context.clip(to: symbol4Rect)
            context.translateBy(x: symbol4Rect.minX, y: symbol4Rect.minY)

            Gates.drawInputPin(frame: CGRect(x: 0, y: 0, width: symbol4Rect.width, height: symbol4Rect.height), highlight: highlight, pinVisible: pin3Visible, invert: pin3Inverted, isJoined: pin3Joined)
            context.restoreGState()




            //// 3Pin2
            //// Symbol 5 Drawing
            let symbol5Rect = CGRect(x: 0, y: 24, width: 30, height: 12)
            context.saveGState()
            context.clip(to: symbol5Rect)
            context.translateBy(x: symbol5Rect.minX, y: symbol5Rect.minY)

            Gates.drawInputPin(frame: CGRect(x: 0, y: 0, width: symbol5Rect.width, height: symbol5Rect.height), highlight: highlight, pinVisible: pin2Visible, invert: pin2Inverted, isJoined: pin2Joined)
            context.restoreGState()




            //// 3Pin1
            //// Symbol 3 Drawing
            let symbol3Rect = CGRect(x: 0, y: 4, width: 26, height: 12)
            context.saveGState()
            context.clip(to: symbol3Rect)
            context.translateBy(x: symbol3Rect.minX, y: symbol3Rect.minY)

            Gates.drawInputPin(frame: CGRect(x: 0, y: 0, width: symbol3Rect.width, height: symbol3Rect.height), highlight: highlight, pinVisible: pin1Visible, invert: pin1Inverted, isJoined: pin1Joined)
            context.restoreGState()




        }


        if (hasInputs4) {
            //// In4
            //// 4Pin4
            //// Symbol 9 Drawing
            let symbol9Rect = CGRect(x: 0, y: 44, width: 26, height: 12)
            context.saveGState()
            context.clip(to: symbol9Rect)
            context.translateBy(x: symbol9Rect.minX, y: symbol9Rect.minY)

            Gates.drawInputPin(frame: CGRect(x: 0, y: 0, width: symbol9Rect.width, height: symbol9Rect.height), highlight: highlight, pinVisible: pin4Visible, invert: pin4Inverted, isJoined: pin4Joined)
            context.restoreGState()




            //// 4Pin3
            //// Symbol 7 Drawing
            let symbol7Rect = CGRect(x: 0, y: 32, width: 30, height: 12)
            context.saveGState()
            context.clip(to: symbol7Rect)
            context.translateBy(x: symbol7Rect.minX, y: symbol7Rect.minY)

            Gates.drawInputPin(frame: CGRect(x: 0, y: 0, width: symbol7Rect.width, height: symbol7Rect.height), highlight: highlight, pinVisible: pin3Visible, invert: pin3Inverted, isJoined: pin3Joined)
            context.restoreGState()




            //// 4Pin2
            //// Symbol 6 Drawing
            let symbol6Rect = CGRect(x: 0, y: 16, width: 29, height: 12)
            context.saveGState()
            context.clip(to: symbol6Rect)
            context.translateBy(x: symbol6Rect.minX, y: symbol6Rect.minY)

            Gates.drawInputPin(frame: CGRect(x: 0, y: 0, width: symbol6Rect.width, height: symbol6Rect.height), highlight: highlight, pinVisible: pin2Visible, invert: pin2Inverted, isJoined: pin2Joined)
            context.restoreGState()




            //// 4Pin1
            //// Symbol 8 Drawing
            let symbol8Rect = CGRect(x: 0, y: 4, width: 26, height: 12)
            context.saveGState()
            context.clip(to: symbol8Rect)
            context.translateBy(x: symbol8Rect.minX, y: symbol8Rect.minY)

            Gates.drawInputPin(frame: CGRect(x: 0, y: 0, width: symbol8Rect.width, height: symbol8Rect.height), highlight: highlight, pinVisible: pin1Visible, invert: pin1Inverted, isJoined: pin1Joined)
            context.restoreGState()




        }


        //// Symbol 10 Drawing
        let symbol10Rect = CGRect(x: 19, y: 0, width: 13, height: 60)
        context.saveGState()
        context.clip(to: symbol10Rect)
        context.translateBy(x: symbol10Rect.minX, y: symbol10Rect.minY)

        Gates.drawShield(frame: CGRect(origin: .zero, size: symbol10Rect.size), resizing: .stretch, highlight: highlight)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawAndPins(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 25, height: 56), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false, inputs: CGFloat = 4, joinedPin: CGFloat = 0, inputPinVisible: CGFloat = 1, invertInput: CGFloat = 0) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 25, height: 56), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 25, y: resizedFrame.height / 56)



        //// Variable Declarations
        let colour = highlight ? Gates.highlightColour : Gates.baseColor
        let hasInputs1 = inputs == 1
        let hasInputs2 = inputs == 2
        let hasInputs3 = inputs == 3
        let hasInputs4 = inputs >= 4
        let pin1Joined = fmod(joinedPin, 2) == 1
        let pin2Joined = fmod(floor(joinedPin / 2.0), 2) == 1
        let pin3Joined = fmod(floor(joinedPin / 4.0), 2) == 1
        let pin4Joined = fmod(floor(joinedPin / 8.0), 2) == 1
        let pin1Visible = inputPinVisible == 1
        let pin2Visible = inputPinVisible == 2
        let pin3Visible = inputPinVisible == 3
        let pin4Visible = inputPinVisible == 4
        let pin1Inverted = fmod(invertInput, 2) == 1
        let pin2Inverted = fmod(floor(invertInput / 2.0), 2) == 1
        let pin3Inverted = fmod(floor(invertInput / 4.0), 2) == 1
        let pin4Inverted = fmod(floor(invertInput / 8.0), 2) == 1

        //// Group
        //// Bezier 10 Drawing
        let bezier10Path = UIBezierPath()
        bezier10Path.move(to: CGPoint(x: 24, y: 56))
        bezier10Path.addLine(to: CGPoint(x: 24, y: 0))
        colour.setStroke()
        bezier10Path.lineWidth = 2.5
        bezier10Path.stroke()


        if (hasInputs4) {
            //// In4
            //// 4Pin4 Drawing
            let _4Pin4Rect = CGRect(x: 0, y: 42, width: 24, height: 12)
            context.saveGState()
            context.clip(to: _4Pin4Rect)
            context.translateBy(x: _4Pin4Rect.minX, y: _4Pin4Rect.minY)

            Gates.drawInputPin(frame: CGRect(x: 0, y: 0, width: _4Pin4Rect.width, height: _4Pin4Rect.height), highlight: highlight, pinVisible: pin4Visible, invert: pin4Inverted, isJoined: pin4Joined)
            context.restoreGState()


            //// 4Pin3 Drawing
            let _4Pin3Rect = CGRect(x: 0, y: 30, width: 24, height: 12)
            context.saveGState()
            context.clip(to: _4Pin3Rect)
            context.translateBy(x: _4Pin3Rect.minX, y: _4Pin3Rect.minY)

            Gates.drawInputPin(frame: CGRect(x: 0, y: 0, width: _4Pin3Rect.width, height: _4Pin3Rect.height), highlight: highlight, pinVisible: pin3Visible, invert: pin3Inverted, isJoined: pin3Joined)
            context.restoreGState()


            //// 4Pin2 Drawing
            let _4Pin2Rect = CGRect(x: 0, y: 14, width: 24, height: 12)
            context.saveGState()
            context.clip(to: _4Pin2Rect)
            context.translateBy(x: _4Pin2Rect.minX, y: _4Pin2Rect.minY)

            Gates.drawInputPin(frame: CGRect(x: 0, y: 0, width: _4Pin2Rect.width, height: _4Pin2Rect.height), highlight: highlight, pinVisible: pin2Visible, invert: pin2Inverted, isJoined: pin2Joined)
            context.restoreGState()


            //// 4Pin1 Drawing
            let _4Pin1Rect = CGRect(x: 0, y: 2, width: 24, height: 12)
            context.saveGState()
            context.clip(to: _4Pin1Rect)
            context.translateBy(x: _4Pin1Rect.minX, y: _4Pin1Rect.minY)

            Gates.drawInputPin(frame: CGRect(x: 0, y: 0, width: _4Pin1Rect.width, height: _4Pin1Rect.height), highlight: highlight, pinVisible: pin1Visible, invert: pin1Inverted, isJoined: pin1Joined)
            context.restoreGState()


        }


        if (hasInputs3) {
            //// In3
            //// 3Pin3 Drawing
            let _3Pin3Rect = CGRect(x: 0, y: 42, width: 24, height: 12)
            context.saveGState()
            context.clip(to: _3Pin3Rect)
            context.translateBy(x: _3Pin3Rect.minX, y: _3Pin3Rect.minY)

            Gates.drawInputPin(frame: CGRect(x: 0, y: 0, width: _3Pin3Rect.width, height: _3Pin3Rect.height), highlight: highlight, pinVisible: pin3Visible, invert: pin3Inverted, isJoined: pin3Joined)
            context.restoreGState()


            //// 3Pin2 Drawing
            let _3Pin2Rect = CGRect(x: 0, y: 22, width: 24, height: 12)
            context.saveGState()
            context.clip(to: _3Pin2Rect)
            context.translateBy(x: _3Pin2Rect.minX, y: _3Pin2Rect.minY)

            Gates.drawInputPin(frame: CGRect(x: 0, y: 0, width: _3Pin2Rect.width, height: _3Pin2Rect.height), highlight: highlight, pinVisible: pin2Visible, invert: pin2Inverted, isJoined: pin2Joined)
            context.restoreGState()


            //// 3Pin1 Drawing
            let _3Pin1Rect = CGRect(x: 0, y: 2, width: 24, height: 12)
            context.saveGState()
            context.clip(to: _3Pin1Rect)
            context.translateBy(x: _3Pin1Rect.minX, y: _3Pin1Rect.minY)

            Gates.drawInputPin(frame: CGRect(x: 0, y: 0, width: _3Pin1Rect.width, height: _3Pin1Rect.height), highlight: highlight, pinVisible: pin1Visible, invert: pin1Inverted, isJoined: pin1Joined)
            context.restoreGState()


        }


        if (hasInputs2) {
            //// In2
            //// 2Pin2 Drawing
            let _2Pin2Rect = CGRect(x: 0, y: 34, width: 24, height: 12)
            context.saveGState()
            context.clip(to: _2Pin2Rect)
            context.translateBy(x: _2Pin2Rect.minX, y: _2Pin2Rect.minY)

            Gates.drawInputPin(frame: CGRect(x: 0, y: 0, width: _2Pin2Rect.width, height: _2Pin2Rect.height), highlight: highlight, pinVisible: pin2Visible, invert: pin2Inverted, isJoined: pin2Joined)
            context.restoreGState()


            //// 2Pin1 Drawing
            let _2Pin1Rect = CGRect(x: 0, y: 10, width: 24, height: 12)
            context.saveGState()
            context.clip(to: _2Pin1Rect)
            context.translateBy(x: _2Pin1Rect.minX, y: _2Pin1Rect.minY)

            Gates.drawInputPin(frame: CGRect(x: 0, y: 0, width: _2Pin1Rect.width, height: _2Pin1Rect.height), highlight: highlight, pinVisible: pin1Visible, invert: pin1Inverted, isJoined: pin1Joined)
            context.restoreGState()


        }


        if (hasInputs1) {
            //// 1Pin1 Drawing
            let _1Pin1Rect = CGRect(x: 0, y: 24, width: 24, height: 8)
            context.saveGState()
            context.clip(to: _1Pin1Rect)
            context.translateBy(x: _1Pin1Rect.minX, y: _1Pin1Rect.minY)

            Gates.drawInputPin(frame: CGRect(x: 0, y: 0, width: _1Pin1Rect.width, height: _1Pin1Rect.height), highlight: highlight, pinVisible: pin1Visible, invert: pin1Inverted, isJoined: pin1Joined)
            context.restoreGState()
        }
        
        context.restoreGState()

    }

    @objc dynamic public class func drawOutputPin(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 24, height: 16), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false, pinVisible: Bool = true, invert: Bool = true, isJoined: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 24, height: 16), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 24, y: resizedFrame.height / 16)



        //// Variable Declarations
        let colour = highlight ? Gates.highlightColour : Gates.baseColor
        let notInvert = !invert

        if (notInvert) {
            //// Noninverting
            //// Bezier 16 Drawing
            let bezier16Path = UIBezierPath()
            bezier16Path.move(to: CGPoint(x: -20, y: 0))
            bezier16Path.addLine(to: CGPoint(x: 0, y: 0))
            colour.setStroke()
            bezier16Path.lineWidth = 2.5
            bezier16Path.stroke()


        }


        if (invert) {
            //// Inverting
            //// Bezier Drawing
            let bezierPath = UIBezierPath()
            bezierPath.move(to: CGPoint(x: -5, y: 0))
            bezierPath.addLine(to: CGPoint(x: 0, y: 0))
            colour.setStroke()
            bezierPath.lineWidth = 2.5
            bezierPath.stroke()


            //// Symbol 2 Drawing
            let symbol2Rect = CGRect(x: -20, y: -8, width: 16, height: 16)
            context.saveGState()
            context.clip(to: symbol2Rect)
            context.translateBy(x: symbol2Rect.minX, y: symbol2Rect.minY)

            Gates.drawNot(frame: CGRect(origin: .zero, size: symbol2Rect.size), resizing: .stretch, highlight: highlight)
            context.restoreGState()


        }


        //// Symbol Drawing
        let symbolRect = CGRect(x: -4, y: -4, width: 8, height: 8)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

        Gates.drawPin(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch, highlight: highlight, pinVisible: pinVisible, isJoined: isJoined)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawInputPin(frame: CGRect = CGRect(x: 0, y: 0, width: 24, height: 12), highlight: Bool = false, pinVisible: Bool = true, invert: Bool = true, isJoined: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }


        //// Variable Declarations
        let colour = highlight ? Gates.highlightColour : Gates.baseColor
        let notInvert = !invert


        //// Subframes
        let inverting: CGRect = CGRect(x: frame.minX + frame.width - 12, y: frame.minY + fastFloor((frame.height - 12) / 2 + 0.5), width: 12, height: 12)


        if (invert) {
            //// Inverting
            //// Symbol 2 Drawing
            let symbol2Rect = CGRect(x: inverting.minX, y: inverting.minY, width: 12, height: 12)
            context.saveGState()
            context.clip(to: symbol2Rect)
            context.translateBy(x: symbol2Rect.minX, y: symbol2Rect.minY)

            Gates.drawNot(frame: CGRect(origin: .zero, size: symbol2Rect.size), resizing: .stretch, highlight: highlight)
            context.restoreGState()


        }


        if (notInvert) {
            //// Bezier 16 Drawing
            let bezier16Path = UIBezierPath()
            bezier16Path.move(to: CGPoint(x: frame.minX + 4, y: frame.minY + 0.50000 * frame.height))
            bezier16Path.addLine(to: CGPoint(x: frame.maxX, y: frame.minY + 0.50000 * frame.height))
            colour.setStroke()
            bezier16Path.lineWidth = 2.5
            bezier16Path.stroke()
        }


        if (invert) {
            //// Bezier Drawing
            let bezierPath = UIBezierPath()
            bezierPath.move(to: CGPoint(x: frame.minX + 4, y: frame.minY + 0.50008 * frame.height))
            bezierPath.addLine(to: CGPoint(x: frame.maxX - 10, y: frame.minY + 0.50008 * frame.height))
            colour.setStroke()
            bezierPath.lineWidth = 2.5
            bezierPath.stroke()
        }


        //// Symbol Drawing
        let symbolRect = CGRect(x: frame.minX, y: frame.minY + fastFloor((frame.height - 8) * 0.50000 + 0.5), width: 8, height: 8)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

        Gates.drawPin(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch, highlight: highlight, pinVisible: pinVisible, isJoined: isJoined)
        context.restoreGState()
    }

    @objc dynamic public class func drawTristateBufferInverterR(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 92, height: 64), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false, joinedPin: CGFloat = 0, joinedOutputPin: CGFloat = 0, inputPinVisible: CGFloat = 1, outputPinVisible: CGFloat = 1, invertInput: CGFloat = 0, invert: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 92, height: 64), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 92, y: resizedFrame.height / 64)



        //// Variable Declarations
        let pin2Joined = fmod(floor(joinedPin / 2.0), 2) == 1
        let pin2Visible = inputPinVisible == 2
        let pin2Inverted = fmod(floor(invertInput / 2.0), 2) == 1

        //// Group
        //// Symbol Drawing
        let symbolRect = CGRect(x: 1, y: 1, width: 90, height: 52)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

        Gates.drawBufferInverterGateR(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch, highlight: highlight, joinedPin: joinedPin, joinedOutputPin: joinedOutputPin, inputPinVisible: inputPinVisible, outputPinVisible: outputPinVisible, invert: invert)
        context.restoreGState()


        //// Symbol 2 Drawing
        context.saveGState()
        context.translateBy(x: 41, y: 63)
        context.rotate(by: -90 * CGFloat.pi/180)

        let symbol2Rect = CGRect(x: 0, y: 0, width: 24, height: 12)
        context.saveGState()
        context.clip(to: symbol2Rect)
        context.translateBy(x: symbol2Rect.minX, y: symbol2Rect.minY)

        Gates.drawInputPin(frame: CGRect(x: 0, y: 0, width: symbol2Rect.width, height: symbol2Rect.height), highlight: highlight, pinVisible: pin2Visible, invert: pin2Inverted, isJoined: pin2Joined)
        context.restoreGState()

        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawOutputR(frame: CGRect = CGRect(x: 0, y: 0, width: 112, height: 30), highlight: Bool = false, joinedPin: CGFloat = 0, inputPinVisible: CGFloat = 1, name: String = "I/O 1") {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }


        //// Variable Declarations
        let colour = highlight ? Gates.highlightColour : Gates.baseColor
        let pin1Joined = fmod(joinedPin, 2) == 1
        let pin1Visible = inputPinVisible == 1

        //// Rectangle Drawing
        let rectanglePath = UIBezierPath()
        rectanglePath.move(to: CGPoint(x: frame.minX + 28.62, y: frame.minY + 3))
        rectanglePath.addLine(to: CGPoint(x: frame.maxX - 16.18, y: frame.minY + 3))
        rectanglePath.addLine(to: CGPoint(x: frame.maxX - 2, y: frame.minY + 0.46667 * frame.height))
        rectanglePath.addLine(to: CGPoint(x: frame.maxX - 16.18, y: frame.maxY - 3))
        rectanglePath.addLine(to: CGPoint(x: frame.minX + 28.62, y: frame.maxY - 3))
        rectanglePath.addCurve(to: CGPoint(x: frame.minX + 26.59, y: frame.maxY - 3.2), controlPoint1: CGPoint(x: frame.minX + 27.58, y: frame.maxY - 3), controlPoint2: CGPoint(x: frame.minX + 27.06, y: frame.maxY - 3))
        rectanglePath.addLine(to: CGPoint(x: frame.minX + 26.5, y: frame.maxY - 3.22))
        rectanglePath.addCurve(to: CGPoint(x: frame.minX + 25.18, y: frame.maxY - 4.89), controlPoint1: CGPoint(x: frame.minX + 25.88, y: frame.maxY - 3.51), controlPoint2: CGPoint(x: frame.minX + 25.4, y: frame.maxY - 4.12))
        rectanglePath.addCurve(to: CGPoint(x: frame.minX + 25, y: frame.maxY - 7.59), controlPoint1: CGPoint(x: frame.minX + 25, y: frame.maxY - 5.61), controlPoint2: CGPoint(x: frame.minX + 25, y: frame.maxY - 6.27))
        rectanglePath.addLine(to: CGPoint(x: frame.minX + 25, y: frame.minY + 7.59))
        rectanglePath.addCurve(to: CGPoint(x: frame.minX + 25.16, y: frame.minY + 5.01), controlPoint1: CGPoint(x: frame.minX + 25, y: frame.minY + 6.27), controlPoint2: CGPoint(x: frame.minX + 25, y: frame.minY + 5.61))
        rectanglePath.addLine(to: CGPoint(x: frame.minX + 25.18, y: frame.minY + 4.89))
        rectanglePath.addCurve(to: CGPoint(x: frame.minX + 26.5, y: frame.minY + 3.22), controlPoint1: CGPoint(x: frame.minX + 25.4, y: frame.minY + 4.12), controlPoint2: CGPoint(x: frame.minX + 25.88, y: frame.minY + 3.51))
        rectanglePath.addCurve(to: CGPoint(x: frame.minX + 28.62, y: frame.minY + 3), controlPoint1: CGPoint(x: frame.minX + 27.06, y: frame.minY + 3), controlPoint2: CGPoint(x: frame.minX + 27.58, y: frame.minY + 3))
        rectanglePath.close()
        colour.setStroke()
        rectanglePath.lineWidth = 2.5
        rectanglePath.stroke()


        //// Text Drawing
        let textRect = CGRect(x: frame.minX + 29, y: frame.minY + fastFloor(frame.height * 0.16667 + 0.5), width: fastFloor((frame.width - 29) * 0.79518 + 0.5), height: fastFloor(frame.height * 0.86667 + 0.5) - fastFloor(frame.height * 0.16667 + 0.5))
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .left
        let textFontAttributes = [
            .font: UIFont(name: "HelveticaNeue-Bold", size: UIFont.labelFontSize)!,
            .foregroundColor: colour,
            .paragraphStyle: textStyle,
        ] as [NSAttributedStringKey: Any]

        let textTextHeight: CGFloat = name.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        name.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()


        //// Symbol Drawing
        let symbolRect = CGRect(x: frame.minX + 1, y: frame.minY + fastFloor((frame.height - 12) * 0.50000 + 0.5), width: 24, height: 12)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

        Gates.drawInputPin(frame: CGRect(x: 0, y: 0, width: symbolRect.width, height: symbolRect.height), highlight: highlight, pinVisible: pin1Visible, invert: false, isJoined: pin1Joined)
        context.restoreGState()
    }

    @objc dynamic public class func drawInputR(frame: CGRect = CGRect(x: 0, y: 0, width: 111, height: 30), highlight: Bool = false, joinedOutputPin: CGFloat = 0, outputPinVisible: CGFloat = 1, name: String = "I/O 1") {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }


        //// Variable Declarations
        let colour = highlight ? Gates.highlightColour : Gates.baseColor
        let outputPin1Joined = fmod(joinedOutputPin, 2) == 1
        let outputPin1Visible = outputPinVisible == 1

        //// Text Drawing
        let textRect = CGRect(x: frame.minX + 7, y: frame.minY + fastFloor(frame.height * 0.16667 + 0.5), width: fastFloor((frame.width - 7) * 0.63462 + 0.5), height: fastFloor(frame.height * 0.86667 + 0.5) - fastFloor(frame.height * 0.16667 + 0.5))
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .left
        let textFontAttributes = [
            .font: UIFont(name: "HelveticaNeue-Bold", size: UIFont.labelFontSize)!,
            .foregroundColor: colour,
            .paragraphStyle: textStyle,
        ] as [NSAttributedStringKey: Any]

        let textTextHeight: CGFloat = name.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        name.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()


        //// Symbol Drawing
        let symbolRect = CGRect(x: frame.minX + frame.width - 25, y: frame.minY + fastFloor((frame.height - 16) * 0.46429) + 0.5, width: 24, height: 16)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)
        context.translateBy(x: 20, y: 8)

        Gates.drawOutputPin(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch, highlight: highlight, pinVisible: outputPin1Visible, invert: false, isJoined: outputPin1Joined)
        context.restoreGState()


        //// Rectangle Drawing
        let rectanglePath = UIBezierPath()
        rectanglePath.move(to: CGPoint(x: frame.minX + 5.62, y: frame.minY + 3))
        rectanglePath.addLine(to: CGPoint(x: frame.maxX - 38.18, y: frame.minY + 3))
        rectanglePath.addLine(to: CGPoint(x: frame.maxX - 25, y: frame.minY + 0.48148 * frame.height))
        rectanglePath.addLine(to: CGPoint(x: frame.maxX - 38.18, y: frame.maxY - 3))
        rectanglePath.addLine(to: CGPoint(x: frame.minX + 5.62, y: frame.maxY - 3))
        rectanglePath.addCurve(to: CGPoint(x: frame.minX + 3.59, y: frame.maxY - 3.2), controlPoint1: CGPoint(x: frame.minX + 4.58, y: frame.maxY - 3), controlPoint2: CGPoint(x: frame.minX + 4.06, y: frame.maxY - 3))
        rectanglePath.addLine(to: CGPoint(x: frame.minX + 3.5, y: frame.maxY - 3.22))
        rectanglePath.addCurve(to: CGPoint(x: frame.minX + 2.18, y: frame.maxY - 4.89), controlPoint1: CGPoint(x: frame.minX + 2.88, y: frame.maxY - 3.51), controlPoint2: CGPoint(x: frame.minX + 2.4, y: frame.maxY - 4.12))
        rectanglePath.addCurve(to: CGPoint(x: frame.minX + 2, y: frame.maxY - 7.59), controlPoint1: CGPoint(x: frame.minX + 2, y: frame.maxY - 5.61), controlPoint2: CGPoint(x: frame.minX + 2, y: frame.maxY - 6.27))
        rectanglePath.addLine(to: CGPoint(x: frame.minX + 2, y: frame.minY + 7.59))
        rectanglePath.addCurve(to: CGPoint(x: frame.minX + 2.16, y: frame.minY + 5.01), controlPoint1: CGPoint(x: frame.minX + 2, y: frame.minY + 6.27), controlPoint2: CGPoint(x: frame.minX + 2, y: frame.minY + 5.61))
        rectanglePath.addLine(to: CGPoint(x: frame.minX + 2.18, y: frame.minY + 4.89))
        rectanglePath.addCurve(to: CGPoint(x: frame.minX + 3.5, y: frame.minY + 3.22), controlPoint1: CGPoint(x: frame.minX + 2.4, y: frame.minY + 4.12), controlPoint2: CGPoint(x: frame.minX + 2.88, y: frame.minY + 3.51))
        rectanglePath.addCurve(to: CGPoint(x: frame.minX + 5.62, y: frame.minY + 3), controlPoint1: CGPoint(x: frame.minX + 4.06, y: frame.minY + 3), controlPoint2: CGPoint(x: frame.minX + 4.58, y: frame.minY + 3))
        rectanglePath.close()
        colour.setStroke()
        rectanglePath.lineWidth = 2.5
        rectanglePath.stroke()
    }

    @objc dynamic public class func drawOscillatorR(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 51, height: 32), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false, joinedOutputPin: CGFloat = 0, outputPinVisible: CGFloat = 1) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 51, height: 32), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 51, y: resizedFrame.height / 32)
        let resizedShadowScale: CGFloat = min(resizedFrame.width / 51, resizedFrame.height / 32)



        //// Variable Declarations
        let colour = highlight ? Gates.highlightColour : Gates.baseColor
        let outputPin1Joined = fmod(joinedOutputPin, 2) == 1
        let outputPin1Visible = outputPinVisible == 1

        //// Group
        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(roundedRect: CGRect(x: 3, y: 3, width: 25, height: 21), cornerRadius: 6)
        context.saveGState()
        context.setShadow(offset: CGSize(width: Gates.shadow.shadowOffset.width * resizedShadowScale, height: Gates.shadow.shadowOffset.height * resizedShadowScale), blur: Gates.shadow.shadowBlurRadius * resizedShadowScale, color: (Gates.shadow.shadowColor as! UIColor).cgColor)
        UIColor.white.setFill()
        rectanglePath.fill()
        context.restoreGState()

        colour.setStroke()
        rectanglePath.lineWidth = 2.5
        rectanglePath.stroke()


        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 7, y: 18))
        bezierPath.addLine(to: CGPoint(x: 10, y: 18))
        bezierPath.addLine(to: CGPoint(x: 10, y: 9))
        bezierPath.addLine(to: CGPoint(x: 20, y: 9))
        bezierPath.addLine(to: CGPoint(x: 20, y: 18))
        bezierPath.addLine(to: CGPoint(x: 23, y: 18))
        colour.setStroke()
        bezierPath.lineWidth = 2
        bezierPath.lineCapStyle = .round
        bezierPath.lineJoinStyle = .round
        bezierPath.stroke()


        //// Symbol Drawing
        let symbolRect = CGRect(x: 27, y: 6, width: 24, height: 16)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)
        context.translateBy(x: 20, y: 8)

        Gates.drawOutputPin(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch, highlight: highlight, pinVisible: outputPin1Visible, invert: false, isJoined: outputPin1Joined)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawBackdrop(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 152, height: 159), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 152, height: 159), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 152, y: resizedFrame.height / 159)


        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 152, height: 159))
        context.saveGState()
        rectanglePath.addClip()
        context.drawLinearGradient(Gates.gradient, start: CGPoint(x: 76, y: 159), end: CGPoint(x: 76, y: 0), options: [])
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawDocImage(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 134, height: 149), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 134, height: 149), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 134, y: resizedFrame.height / 149)



        //// Gradient Declarations
        let whiteGradient = CGGradient(colorsSpace: nil, colors: [UIColor.white.cgColor, UIColor.white.cgColor] as CFArray, locations: [0, 1])!
        let selectedGradient = CGGradient(colorsSpace: nil, colors: [UIColor.white.cgColor, UIColor.white.blended(withFraction: 0.5, of: Gates.buttonLo).cgColor, Gates.buttonLo.cgColor] as CFArray, locations: [0, 0.86, 1])!

        //// Variable Declarations
        let colour = highlight ? Gates.highlightColour : Gates.baseColor
        let docFill = highlight ? selectedGradient : whiteGradient

        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(roundedRect: CGRect(x: 1, y: 1, width: 132, height: 147), cornerRadius: 6)
        context.saveGState()
        rectanglePath.addClip()
        context.drawLinearGradient(docFill, start: CGPoint(x: 67, y: 1), end: CGPoint(x: 67, y: 148), options: [])
        context.restoreGState()
        colour.setStroke()
        rectanglePath.lineWidth = 2
        rectanglePath.stroke()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawAndNandGateL(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 120, height: 60), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false, inputs: CGFloat = 4, joinedPin: CGFloat = 0, joinedOutputPin: CGFloat = 0, inputPinVisible: CGFloat = 1, outputPinVisible: CGFloat = 1, invertInput: CGFloat = 0, invert: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 120, height: 60), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 120, y: resizedFrame.height / 60)


        //// Symbol Drawing
        context.saveGState()
        context.translateBy(x: 120, y: 0)
        context.scaleBy(x: -1, y: 1)

        let symbolRect = CGRect(x: 0, y: 0, width: 120, height: 60)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

        Gates.drawAndNandGateR(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch, highlight: highlight, inputs: inputs, joinedPin: joinedPin, joinedOutputPin: joinedOutputPin, inputPinVisible: inputPinVisible, outputPinVisible: outputPinVisible, invertInput: invertInput, invert: invert)
        context.restoreGState()

        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawOrNorGateL(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 124, height: 60), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false, inputs: CGFloat = 4, joinedPin: CGFloat = 0, joinedOutputPin: CGFloat = 0, inputPinVisible: CGFloat = 1, outputPinVisible: CGFloat = 1, invertInput: CGFloat = 0, invert: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 124, height: 60), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 124, y: resizedFrame.height / 60)


        //// Symbol Drawing
        context.saveGState()
        context.translateBy(x: 124, y: 0)
        context.scaleBy(x: -1, y: 1)

        let symbolRect = CGRect(x: 0, y: 0, width: 124, height: 60)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

        Gates.drawOrNorGateR(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch, highlight: highlight, inputs: inputs, joinedPin: joinedPin, joinedOutputPin: joinedOutputPin, inputPinVisible: inputPinVisible, outputPinVisible: outputPinVisible, invertInput: invertInput, invert: invert)
        context.restoreGState()

        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawXorXnorGateL(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 132, height: 60), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false, inputs: CGFloat = 4, joinedPin: CGFloat = 0, joinedOutputPin: CGFloat = 0, inputPinVisible: CGFloat = 1, outputPinVisible: CGFloat = 1, invertInput: CGFloat = 0, invert: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 132, height: 60), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 132, y: resizedFrame.height / 60)


        //// Symbol Drawing
        context.saveGState()
        context.translateBy(x: 132, y: 0)
        context.scaleBy(x: -1, y: 1)

        let symbolRect = CGRect(x: 0, y: 0, width: 132, height: 60)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

        Gates.drawXorXnorGateR(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch, highlight: highlight, inputs: inputs, joinedPin: joinedPin, joinedOutputPin: joinedOutputPin, inputPinVisible: inputPinVisible, outputPinVisible: outputPinVisible, invertInput: invertInput, invert: invert)
        context.restoreGState()

        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawBufferInverterGateL(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 90, height: 52), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false, joinedPin: CGFloat = 0, joinedOutputPin: CGFloat = 0, inputPinVisible: CGFloat = 1, outputPinVisible: CGFloat = 1, invert: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 90, height: 52), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 90, y: resizedFrame.height / 52)


        //// Symbol Drawing
        context.saveGState()
        context.translateBy(x: 90, y: 0)
        context.scaleBy(x: -1, y: 1)

        let symbolRect = CGRect(x: 0, y: 0, width: 90, height: 52)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

        Gates.drawBufferInverterGateR(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch, highlight: highlight, joinedPin: joinedPin, joinedOutputPin: joinedOutputPin, inputPinVisible: inputPinVisible, outputPinVisible: outputPinVisible, invert: invert)
        context.restoreGState()

        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawIndicatorL(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 57, height: 35), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false, state: CGFloat = 0, joinedPin: CGFloat = 0, inputPinVisible: CGFloat = 1) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 57, height: 35), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 57, y: resizedFrame.height / 35)


        //// Symbol Drawing
        context.saveGState()
        context.translateBy(x: 57, y: 0)
        context.scaleBy(x: -1, y: 1)

        let symbolRect = CGRect(x: 0, y: 0, width: 57, height: 35)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

        Gates.drawIndicatorR(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch, highlight: highlight, state: state, joinedPin: joinedPin, inputPinVisible: inputPinVisible)
        context.restoreGState()

        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawOscillatorL(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 51, height: 32), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false, joinedOutputPin: CGFloat = 0, outputPinVisible: CGFloat = 1) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 51, height: 32), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 51, y: resizedFrame.height / 32)


        //// Symbol Drawing
        context.saveGState()
        context.translateBy(x: 51, y: 0)
        context.scaleBy(x: -1, y: 1)

        let symbolRect = CGRect(x: 0, y: 0, width: 51, height: 32)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

        Gates.drawOscillatorR(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch, highlight: highlight, joinedOutputPin: joinedOutputPin, outputPinVisible: outputPinVisible)
        context.restoreGState()

        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawButtonL(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 52, height: 32), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false, state: CGFloat = 0, joinedOutputPin: CGFloat = 0, outputPinVisible: CGFloat = 1) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 52, height: 32), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 52, y: resizedFrame.height / 32)


        //// Symbol Drawing
        context.saveGState()
        context.translateBy(x: 52, y: 0)
        context.scaleBy(x: -1, y: 1)

        let symbolRect = CGRect(x: 0, y: 0, width: 52, height: 32)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

        Gates.drawButtonR(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch, highlight: highlight, state: state, joinedOutputPin: joinedOutputPin, outputPinVisible: outputPinVisible)
        context.restoreGState()

        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawTristateBufferInverterL(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 92, height: 64), resizing: ResizingBehavior = .aspectFit, highlight: Bool = false, joinedPin: CGFloat = 0, joinedOutputPin: CGFloat = 0, inputPinVisible: CGFloat = 1, outputPinVisible: CGFloat = 1, invertInput: CGFloat = 0, invert: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 92, height: 64), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 92, y: resizedFrame.height / 64)


        //// Symbol Drawing
        context.saveGState()
        context.translateBy(x: 92, y: 0)
        context.scaleBy(x: -1, y: 1)

        let symbolRect = CGRect(x: 0, y: 0, width: 92, height: 64)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

        Gates.drawTristateBufferInverterR(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch, highlight: highlight, joinedPin: joinedPin, joinedOutputPin: joinedOutputPin, inputPinVisible: inputPinVisible, outputPinVisible: outputPinVisible, invertInput: invertInput, invert: invert)
        context.restoreGState()

        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawInputL(frame: CGRect = CGRect(x: 0, y: 0, width: 111, height: 30), highlight: Bool = false, joinedOutputPin: CGFloat = 0, outputPinVisible: CGFloat = 1, name: String = "I/O 1") {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }


        //// Variable Declarations
        let colour = highlight ? Gates.highlightColour : Gates.baseColor
        let outputPin1Joined = fmod(joinedOutputPin, 2) == 1
        let outputPin1Visible = outputPinVisible == 1

        //// Text Drawing
        let textRect = CGRect(x: frame.minX + 39, y: frame.minY + fastFloor(frame.height * 0.16667 + 0.5), width: fastFloor((frame.width - 39) * 0.91667 + 0.5), height: fastFloor(frame.height * 0.86667 + 0.5) - fastFloor(frame.height * 0.16667 + 0.5))
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .left
        let textFontAttributes = [
            .font: UIFont(name: "HelveticaNeue-Bold", size: UIFont.labelFontSize)!,
            .foregroundColor: colour,
            .paragraphStyle: textStyle,
        ] as [NSAttributedStringKey: Any]

        let textTextHeight: CGFloat = name.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        name.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()


        //// Symbol Drawing
        context.saveGState()
        context.translateBy(x: frame.maxX - 85, y: frame.minY + 0.23333 * frame.height)
        context.scaleBy(x: -1, y: 1)

        let symbolRect = CGRect(x: 0, y: 0, width: 24, height: 16)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)
        context.translateBy(x: 20, y: 8)

        Gates.drawOutputPin(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch, highlight: highlight, pinVisible: outputPin1Visible, invert: false, isJoined: outputPin1Joined)
        context.restoreGState()

        context.restoreGState()


        //// Rectangle Drawing
        let rectanglePath = UIBezierPath()
        rectanglePath.move(to: CGPoint(x: frame.maxX - 4.71, y: frame.minY + 3))
        rectanglePath.addLine(to: CGPoint(x: frame.minX + 37.45, y: frame.minY + 3))
        rectanglePath.addLine(to: CGPoint(x: frame.minX + 26, y: frame.minY + 0.50000 * frame.height))
        rectanglePath.addLine(to: CGPoint(x: frame.minX + 37.27, y: frame.maxY - 3))
        rectanglePath.addLine(to: CGPoint(x: frame.maxX - 4.71, y: frame.maxY - 3))
        rectanglePath.addCurve(to: CGPoint(x: frame.maxX - 2.63, y: frame.maxY - 3.2), controlPoint1: CGPoint(x: frame.maxX - 3.64, y: frame.maxY - 3), controlPoint2: CGPoint(x: frame.maxX - 3.11, y: frame.maxY - 3))
        rectanglePath.addLine(to: CGPoint(x: frame.maxX - 2.53, y: frame.maxY - 3.22))
        rectanglePath.addCurve(to: CGPoint(x: frame.maxX - 1.18, y: frame.maxY - 4.89), controlPoint1: CGPoint(x: frame.maxX - 1.91, y: frame.maxY - 3.51), controlPoint2: CGPoint(x: frame.maxX - 1.41, y: frame.maxY - 4.12))
        rectanglePath.addCurve(to: CGPoint(x: frame.maxX - 1, y: frame.maxY - 7.59), controlPoint1: CGPoint(x: frame.maxX - 1, y: frame.maxY - 5.61), controlPoint2: CGPoint(x: frame.maxX - 1, y: frame.maxY - 6.27))
        rectanglePath.addLine(to: CGPoint(x: frame.maxX - 1, y: frame.minY + 7.59))
        rectanglePath.addCurve(to: CGPoint(x: frame.maxX - 1.16, y: frame.minY + 5.01), controlPoint1: CGPoint(x: frame.maxX - 1, y: frame.minY + 6.27), controlPoint2: CGPoint(x: frame.maxX - 1, y: frame.minY + 5.61))
        rectanglePath.addLine(to: CGPoint(x: frame.maxX - 1.18, y: frame.minY + 4.89))
        rectanglePath.addCurve(to: CGPoint(x: frame.maxX - 2.53, y: frame.minY + 3.22), controlPoint1: CGPoint(x: frame.maxX - 1.41, y: frame.minY + 4.12), controlPoint2: CGPoint(x: frame.maxX - 1.91, y: frame.minY + 3.51))
        rectanglePath.addCurve(to: CGPoint(x: frame.maxX - 4.71, y: frame.minY + 3), controlPoint1: CGPoint(x: frame.maxX - 3.11, y: frame.minY + 3), controlPoint2: CGPoint(x: frame.maxX - 3.64, y: frame.minY + 3))
        rectanglePath.close()
        colour.setStroke()
        rectanglePath.lineWidth = 2.5
        rectanglePath.stroke()
    }

    @objc dynamic public class func drawOutputL(frame: CGRect = CGRect(x: 0, y: 0, width: 112, height: 30), highlight: Bool = false, joinedPin: CGFloat = 0, inputPinVisible: CGFloat = 1, name: String = "I/O 1") {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }


        //// Variable Declarations
        let colour = highlight ? Gates.highlightColour : Gates.baseColor
        let pin1Joined = fmod(joinedPin, 2) == 1
        let pin1Visible = inputPinVisible == 1

        //// Rectangle Drawing
        let rectanglePath = UIBezierPath()
        rectanglePath.move(to: CGPoint(x: frame.maxX - 28.62, y: frame.minY + 3))
        rectanglePath.addLine(to: CGPoint(x: frame.minX + 16.18, y: frame.minY + 3))
        rectanglePath.addLine(to: CGPoint(x: frame.minX + 3, y: frame.minY + 0.50000 * frame.height))
        rectanglePath.addLine(to: CGPoint(x: frame.minX + 16, y: frame.maxY - 3))
        rectanglePath.addLine(to: CGPoint(x: frame.maxX - 28.62, y: frame.maxY - 3))
        rectanglePath.addCurve(to: CGPoint(x: frame.maxX - 26.59, y: frame.maxY - 3.2), controlPoint1: CGPoint(x: frame.maxX - 27.58, y: frame.maxY - 3), controlPoint2: CGPoint(x: frame.maxX - 27.06, y: frame.maxY - 3))
        rectanglePath.addLine(to: CGPoint(x: frame.maxX - 26.5, y: frame.maxY - 3.22))
        rectanglePath.addCurve(to: CGPoint(x: frame.maxX - 25.18, y: frame.maxY - 4.89), controlPoint1: CGPoint(x: frame.maxX - 25.88, y: frame.maxY - 3.51), controlPoint2: CGPoint(x: frame.maxX - 25.4, y: frame.maxY - 4.12))
        rectanglePath.addCurve(to: CGPoint(x: frame.maxX - 25, y: frame.maxY - 7.59), controlPoint1: CGPoint(x: frame.maxX - 25, y: frame.maxY - 5.61), controlPoint2: CGPoint(x: frame.maxX - 25, y: frame.maxY - 6.27))
        rectanglePath.addLine(to: CGPoint(x: frame.maxX - 25, y: frame.minY + 7.59))
        rectanglePath.addCurve(to: CGPoint(x: frame.maxX - 25.16, y: frame.minY + 5.01), controlPoint1: CGPoint(x: frame.maxX - 25, y: frame.minY + 6.27), controlPoint2: CGPoint(x: frame.maxX - 25, y: frame.minY + 5.61))
        rectanglePath.addLine(to: CGPoint(x: frame.maxX - 25.18, y: frame.minY + 4.89))
        rectanglePath.addCurve(to: CGPoint(x: frame.maxX - 26.5, y: frame.minY + 3.22), controlPoint1: CGPoint(x: frame.maxX - 25.4, y: frame.minY + 4.12), controlPoint2: CGPoint(x: frame.maxX - 25.88, y: frame.minY + 3.51))
        rectanglePath.addCurve(to: CGPoint(x: frame.maxX - 28.62, y: frame.minY + 3), controlPoint1: CGPoint(x: frame.maxX - 27.06, y: frame.minY + 3), controlPoint2: CGPoint(x: frame.maxX - 27.58, y: frame.minY + 3))
        rectanglePath.close()
        colour.setStroke()
        rectanglePath.lineWidth = 2.5
        rectanglePath.stroke()


        //// Text Drawing
        let textRect = CGRect(x: frame.minX + 16, y: frame.minY + fastFloor(frame.height * 0.10000 + 0.5), width: fastFloor((frame.width - 16) * 0.68750 + 0.5), height: fastFloor(frame.height * 0.86667 + 0.5) - fastFloor(frame.height * 0.10000 + 0.5))
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .left
        let textFontAttributes = [
            .font: UIFont(name: "HelveticaNeue-Bold", size: UIFont.labelFontSize)!,
            .foregroundColor: colour,
            .paragraphStyle: textStyle,
        ] as [NSAttributedStringKey: Any]

        let textTextHeight: CGFloat = name.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        name.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()


        //// Symbol Drawing
        context.saveGState()
        context.translateBy(x: frame.maxX, y: frame.minY + 0.30000 * frame.height)
        context.scaleBy(x: -1, y: 1)

        let symbolRect = CGRect(x: 0, y: 0, width: 24, height: 12)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

        Gates.drawInputPin(frame: CGRect(x: 0, y: 0, width: symbolRect.width, height: symbolRect.height), highlight: highlight, pinVisible: pin1Visible, invert: false, isJoined: pin1Joined)
        context.restoreGState()

        context.restoreGState()
    }

    //// Generated Images

    @objc dynamic public class func imageOfDocImage(highlight: Bool = false) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 134, height: 149), false, 0)
            Gates.drawDocImage(highlight: highlight)

        let imageOfDocImage = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfDocImage
    }




    @objc(GatesResizingBehavior)
    public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
                case .aspectFit:
                    scales.width = min(scales.width, scales.height)
                    scales.height = scales.width
                case .aspectFill:
                    scales.width = max(scales.width, scales.height)
                    scales.height = scales.width
                case .stretch:
                    break
                case .center:
                    scales.width = 1
                    scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}



private extension UIColor {
    func blended(withFraction fraction: CGFloat, of color: UIColor) -> UIColor {
        var r1: CGFloat = 1, g1: CGFloat = 1, b1: CGFloat = 1, a1: CGFloat = 1
        var r2: CGFloat = 1, g2: CGFloat = 1, b2: CGFloat = 1, a2: CGFloat = 1

        self.getRed(&r1, green: &g1, blue: &b1, alpha: &a1)
        color.getRed(&r2, green: &g2, blue: &b2, alpha: &a2)

        return UIColor(red: r1 * (1 - fraction) + r2 * fraction,
            green: g1 * (1 - fraction) + g2 * fraction,
            blue: b1 * (1 - fraction) + b2 * fraction,
            alpha: a1 * (1 - fraction) + a2 * fraction);
    }
}



private extension NSShadow {
    convenience init(color: AnyObject!, offset: CGSize, blurRadius: CGFloat) {
        self.init()
        self.shadowColor = color
        self.shadowOffset = offset
        self.shadowBlurRadius = blurRadius
    }
}
